import io
from typing import List

import qrcode
import streamlit as st

from app_utils_core import (
    suggest_addresses,
    resolve_selection,
    build_gmaps_url,
    build_waze_url,
    build_apple_maps_url,
    build_gmaps_android_intent_url,
)

# -----------------------
# Config
# -----------------------
MAX_POINTS = 10
COUNTRY_SUFFIX = ", Espa√±a"  # aj√∫stalo si trabajas en otro pa√≠s

# Evita que Google meta POIs ‚Äúraros‚Äù para nombres gen√©ricos
AMBIGUOUS_TOKENS = {
    "barcelona","madrid","valencia","toledo","sevilla","bilbao","zaragoza","girona",
    "paris","roma","lugo","caceres","soria","leon","avila","burgos","pamplona",
    "malaga","cordoba","granada","alicante","castellon","tarragona","lleida","lerida"
}

# Blacklist para eliminar POIs concretos (workaround inmediato)
BLACKLIST_SUBSTRINGS = [
    "optimize logistic solutions",   # <- culpable principal
]

# -----------------------
# Utils
# -----------------------
def _qr_png_bytes(url: str) -> bytes:
    img = qrcode.make(url)
    buf = io.BytesIO()
    img.save(buf, format="PNG")
    return buf.getvalue()

def _normalize_label(label: str) -> str:
    """Refuerza nombres cortos/ciudades para que Google no elija negocios."""
    s = (label or "").strip()
    if not s:
        return s
    # Si es 1‚Äì2 palabras sin coma, a√±ade pa√≠s
    if "," not in s and len(s.split()) <= 2:
        s = s + COUNTRY_SUFFIX
    # Si es exactamente una ciudad ambigua, refuerza ‚ÄúCiudad‚Äù
    low = s.lower().replace(COUNTRY_SUFFIX.lower(), "").strip()
    if low in AMBIGUOUS_TOKENS:
        s = s.replace(COUNTRY_SUFFIX, "") + ", Ciudad" + COUNTRY_SUFFIX
    return s

def _sanitize_points(points: List[str]) -> List[str]:
    """Normaliza y elimina POIs en blacklist."""
    out = []
    for p in points:
        # quita si coincide con blacklist
        low = p.lower()
        if any(bad in low for bad in BLACKLIST_SUBSTRINGS):
            continue
        out.append(_normalize_label(p))
    return out

def _init_state():
    ss = st.session_state
    ss.setdefault("prof_points", [])
    ss.setdefault("prof_text_input", "")
    ss.setdefault("prof_selection", "")
    ss.setdefault("prof_mode", "M√°s r√°pido")
    ss.setdefault("prof_avoid", "Ninguno")
    ss.setdefault("prof_open_target", "Navegador")
    ss.setdefault("prof_last_route_url", "")
    ss.setdefault("_prof_clear_on_rerun", False)
    ss.setdefault("_prof_clear_sel_on_rerun", False)

# -----------------------
# Mutaciones (lista)
# -----------------------
def _add_point(value: str):
    ss = st.session_state
    if len(ss["prof_points"]) >= MAX_POINTS:
        return
    v = (value or "").strip()
    if v:
        ss["prof_points"].append(v)

def _del_point(i: int):
    pts = st.session_state["prof_points"]
    if 0 <= i < len(pts):
        pts.pop(i)

def _move_up(i: int):
    pts = st.session_state["prof_points"]
    if 0 < i < len(pts):
        pts[i-1], pts[i] = pts[i], pts[i-1]

def _move_down(i: int):
    pts = st.session_state["prof_points"]
    if 0 <= i < len(pts)-1:
        pts[i+1], pts[i] = pts[i], pts[i+1]

def _clear_points():
    ss = st.session_state
    ss["prof_points"] = []
    ss["_prof_clear_on_rerun"] = True
    ss["_prof_clear_sel_on_rerun"] = True

# -----------------------
# UI: buscador + opciones
# -----------------------
def _search_and_options_row():
    ss = st.session_state
    if ss.pop("_prof_clear_on_rerun", False):
        ss["prof_text_input"] = ""
    if ss.pop("_prof_clear_sel_on_rerun", False):
        ss["prof_selection"] = ""

    col_search, col_mode, col_avoid = st.columns([2.5, 1, 1])

    with col_search:
        with st.form("prof_add_form", clear_on_submit=False):
            term = st.text_input(
                "Buscar direcci√≥n‚Ä¶",
                key="prof_text_input",
                label_visibility="collapsed",
                placeholder=f"Escribe la direcci√≥n (m√≠n. 3 letras, m√°x. {MAX_POINTS} puntos).",
            )
            suggestions = []
            if len((term or "").strip()) >= 3:
                try:
                    suggestions = suggest_addresses(term.strip(), min_len=3, max_results=8)
                except Exception:
                    suggestions = []
            if suggestions:
                st.selectbox(
                    "Sugerencias:",
                    options=[s["description"] for s in suggestions],
                    key="prof_selection",
                    label_visibility="visible",
                )

            c1, c2 = st.columns([1.3, 1])
            submitted = c1.form_submit_button("A√±adir", type="primary", use_container_width=True)
            limpiar   = c2.form_submit_button("Limpiar", use_container_width=True)

        if submitted:
            candidate = ss.get("prof_selection") or ss.get("prof_text_input", "")
            if candidate:
                _add_point(candidate)
                ss["_prof_clear_on_rerun"] = True
                ss["_prof_clear_sel_on_rerun"] = True
                st.rerun()
        if limpiar:
            _clear_points()
            st.rerun()

    with col_mode:
        st.selectbox("Tipo de ruta", ["M√°s r√°pido", "M√°s corto"], key="prof_mode")
    with col_avoid:
        st.selectbox("Evitar", ["Ninguno", "Peajes", "Ferries"], key="prof_avoid")

    st.selectbox("Abrir en", ["Navegador", "App"], key="prof_open_target")

# -----------------------
# UI: lista editable (‚Üë ‚Üì ‚úñ)
# -----------------------
def _render_points():
    pts = st.session_state["prof_points"]
    st.subheader(f"Puntos ({len(pts)}/{MAX_POINTS})")
    if not pts:
        st.info("A√±ade al menos origen y destino.")
        return

    for i, p in enumerate(pts):
        c_text, c_up, c_down, c_del = st.columns([8, 1, 1, 1])
        with c_text:
            st.write(f"{i+1}.  {p}")
        with c_up:
            st.button("‚Üë", key=f"up_{i}", on_click=_move_up, args=(i,), use_container_width=True, disabled=(i==0))
        with c_down:
            st.button("‚Üì", key=f"down_{i}", on_click=_move_down, args=(i,), use_container_width=True, disabled=(i==len(pts)-1))
        with c_del:
            st.button("‚úñ", key=f"del_{i}", on_click=_del_point, args=(i,), use_container_width=True)

# -----------------------
# Entrada principal
# -----------------------
def mostrar_profesional():
    _init_state()
    ss = st.session_state

    st.header("Planificador de rutas")
    _search_and_options_row()
    _render_points()

    pts = ss["prof_points"]
    st.markdown("---")
    if st.button("Generar ruta profesional", type="primary", use_container_width=True):
        if len(pts) < 2:
            st.warning("Necesitas al menos origen y destino.")
            return

        clean_pts = _sanitize_points(pts)
        if len(clean_pts) < 2:
            st.error("Tras limpiar/normalizar puntos, qued√≥ < 2. Revisa las direcciones.")
            return

        origen_label   = clean_pts[0]
        destino_label  = clean_pts[-1]
        waypoints_lbls = clean_pts[1:-1]

        origen_meta  = resolve_selection(origen_label, None)
        destino_meta = resolve_selection(destino_label, None)
        waypoints_resolved = [
            resolve_selection(lbl, None).get("address", lbl) for lbl in waypoints_lbls
        ]

        avoid_map = {"Peajes": "tolls", "Ferries": "ferries", "Ninguno": None}

        gmaps_web = build_gmaps_url(
            origin=origen_meta.get("address", origen_label),
            destination=destino_meta.get("address", destino_label),
            waypoints=waypoints_resolved,
            mode="driving",
            avoid=avoid_map.get(ss["prof_avoid"]),
            optimize=True,
        )

        gmaps_app = build_gmaps_android_intent_url(
            origin=origen_meta.get("address", origen_label),
            destination=destino_meta.get("address", destino_label),
            waypoints=waypoints_resolved,
            mode="driving",
            avoid=avoid_map.get(ss["prof_avoid"]),
        )

        waze_url  = build_waze_url(origen_meta.get("address", origen_label),
                                   destino_meta.get("address", destino_label))
        apple_url = build_apple_maps_url(origen_meta.get("address", origen_label),
                                         destino_meta.get("address", destino_label))

        ss["prof_last_route_url"] = gmaps_web

        st.success("Ruta generada. Elige c√≥mo abrirla üëá")
        c1, c2, c3 = st.columns(3)
        with c1:
            if ss["prof_open_target"] == "App" and gmaps_app:
                st.markdown(f'<a href="{gmaps_app}"><button>üì± Maps (App)</button></a>',
                            unsafe_allow_html=True)
            else:
                st.link_button("üåê Maps (Web)", gmaps_web)
        with c2:
            st.link_button("üöó Waze", waze_url)
        with c3:
            st.link_button("üçé Apple", apple_url)

        with st.expander("üì∑ QR de la ruta (Google Web)"):
            st.image(_qr_png_bytes(gmaps_web), caption="Escan√©alo desde el m√≥vil")
